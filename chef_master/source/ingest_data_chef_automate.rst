=====================================================
Ingest Node Data into |automate|
=====================================================

.. include:: ../../includes_chef_automate/includes_chef_automate_mark.rst 

To view data in the **Node State** dashboard of |automate|, it must be ingested from 
Chef clients and/or servers through HTTP POST requests to a data collector endpoint on the |automate| server. 
Node data, resource convergence status, error messages, and other information is collected during chef-client runs and 
used to populate the dashboard. 

Prerequisites
================================================================

* Chef Client (version 12.12.15 or greater)
* Chef Server (version 12.8 or greater)

Configuring Chef Client to send node and converge data
=======================================================

The data collector functionality is used by the Chef Client to send node and converge data to |automate|. This 
feature works for the following: Chef Client, Chef Solo (formerly "Chef Client LocalMode"), and Chef Solo Legacy Mode 
(formerly "Chef Solo").

To send node and converge data to |automate|, modify your Chef config (that is
`client.rb`, `solo.rb`, or add an additional config file in an appropriate directory, such as
`client.d`) to contain the following configuration:

.. code-block:: ruby

   data_collector.server_url "https://my-automate-server.mycompany.com/data-collector/v0/"
   data_collector.token "TOKEN"

where ``my-automate-server.mycompany.com`` is the fully-qualified domain name of your Chef Automate server and
``TOKEN`` is the token you configured in :doc:`Setup and Configure Visibility in Chef Automate </setup_visibility_chef_automate>`.

Additional configuration options include:

  * ``data_collector.mode``: The mode in which the data collector is allowed to operate. This
    can be used to run data collector only when running as Chef Solo but not when using Chef Client.
    Options: ``:solo`` (for both Solo Legacy Mode and Solo Mode), ``:client``, or ``:both`.  Default:
    ``:both``.
  * ``data_collector.raise_on_failure``: When the data collector cannot send the "starting a run"
    message to the data collector server, the data collector will be disabled for that run. In some
    situations, such as highly-regulated environments, it may be more reasonable to prevent Chef
    from performing the actual run. In these situations, setting this value to ``true`` will cause the
    Chef run to raise an exception before starting any converge activities. Default: ``false``.
  * ``data_collector.organization``: A user-supplied organization string that can be sent in
    payloads generated by the data collector when Chef is run in Solo mode. This allows users to
    associate their Solo nodes with faux organizations without the nodes being connected to an
    actual Chef Server.

Configuring Chef Server to send Chef Client data
=================================================

Chef Server can be configured to send messages to |automate| whenever an action is taken on a Chef
Server object. For example, messages can be sent when a role is updated, a node is created, or a
cookbook is uploaded.

To enable this feature, add the following settings to ``/etc/opscode/chef-server.rb`` on your Chef
Server:

.. code-block:: ruby

   data_collector['root_url'] = 'https://my-automate-server.mycompany.com/data-collector/v0/'
   data_collector['token'] = 'TOKEN'

where ``my-automate-server.mycompany.com`` is the fully-qualified domain name of your Chef Automate server, and
``TOKEN`` is the token you configured in :doc:`Setup and Configure Visibility in Chef Automate </setup_visibility_chef_automate>`.

Save the file and run ``chef-server-ctl reconfigure`` to complete the process.

Additional configuration options include:

 * ``data_collector['timeout']``: timeout in milliseconds to abort an attempt to send a message to the
   |automate| server. Default: ``30000``.
 * ``data_collector['http_init_count']``: number of |automate| HTTP workers Chef Server should start.
   Default: ``25``.
 * ``data_collector['http_max_count']``: maximum number of |automate| HTTP workers Chef Server should
   allow to exist at any time. Default: ``100``.
 * ``data_collector['http_max_age']``: maximum age a |automate| HTTP worker should be allowed to live,
   specified as an Erlang tuple. Default: ``{70, sec}``.
 * ``data_collector['http_cull_interval']``: how often Chef Server should cull aged-out |automate|
   HTTP workers that have exceeded their ``http_max_age``, specified as an Erlang tuple. Default: ``{1,
   min}``.
 * ``data_collector['http_max_connection_duration']``: maximum duration an HTTP connection is allowed
   to exist before it is terminated, specified as an Erlang tuple. Default: ``{70, sec}``.

.. note:: If you define a new organization in your Chef server, but it does not have any nodes associated with it, that organization will not show up in the **Nodes** section of the |automate| UI. This is also true for roles, cookbooks, recipes, attributes, resources, node names, and environments that are not associated with a node in the |automate| cluster.

Configuring Chef Client to send InSpec data
===========================================

To send InSpec data as part of a Chef client run, you will require the `audit cookbook <https://github.com/chef-cookbooks/audit>`_. All profiles, that are configured to run during the audit cookbook execution, will send their results back to the Chef Automate server.

To configure the audit cookbook, you will first need to configure the Chef Client to send node converge data (see above). The ``data_collector.server_url`` and ``data_collector.token`` values will be used as the reporting targets.

Once these prerequisites are met, the audit cookbook's collector is configured to send data to Chef Automate by setting the ``audit.collector`` attribute to ``chef-visibility``. A complete audit cookbook attribute configuration will now look like this:

.. code-block:: javascript

    audit: {
      collector: 'chef-visibility',
      profiles: {
        'cis/cis-centos6-level1' => true
      }
    }

Adding Chef Automate certificate to `trusted_certs` directory
================================================================

The visibilty features of |automate| require that any self-signed |automate| SSL certificate (``delivery.HOSTNAME.crt``) is located 
in the ``/etc/chef/trusted_certs`` directory on any node that wants to send data to |automate|. This directory is the location into 
which |ssl| certificates are placed when a node has been bootstrapped with |chef client|. 

To ensure the certificate is in the ``trusted_certs`` directory, you can use utilities such as `scp` or `rsync` to copy 
``/var/opt/delivery/nginx/ca/delivery.HOSTNAME.crt`` from the |automate| server to the ``/etc/chef/trusted_certs`` directory on the 
node in your |automate| cluster, or use ``knife ssl fetch`` and pass in the URL of the |automate| server when calling the ``fetch`` subcommand.

.. note:: This only applies to self-signed SSL certificates. Any certificate signed by certificate authority should work without any additional configuration required.